/*============================================================
 * main.c  --  基于STC89C52单片机的智能汽车雨刮器模拟系统
 *             主程序（完整版，数码管+OLED双显示）
 *
 * 作者：梁嘉惠  学号：3222004950
 * 学校：五邑大学 电子与信息工程学院  班级：220710
 * 指导教师：龙佳乐 副教授
 * 编译器：Keil C51  主频：11.0592MHz
 * 版本：V4.0  日期：2025年12月
 *============================================================
 * 硬件资源分配总览：
 *
 *  ── 数码管显示（开题报告必要功能） ──
 *   P0.0 → 74HC595 SER  (段码串行数据)
 *   P0.1 → 74HC595 RCLK (存储时钟)
 *   P0.2 → 74HC595 SRCLK(移位时钟)
 *   P2.4 → 数码管COM1   (千位，经S8050三极管驱动)
 *   P2.5 → 数码管COM2   (百位)
 *   P2.6 → 数码管COM3   (十位)
 *   P2.7 → 数码管COM4   (个位)
 *
 *  ── OLED显示（成品扩展功能） ──
 *   P1.6 → OLED SCL    (I2C时钟，外接4.7kΩ上拉到5V)
 *   P1.7 → OLED SDA    (I2C数据，外接4.7kΩ上拉到5V)
 *
 *  ── ADC0832（雨量采集） ──
 *   P1.0 → ADC0832 CS
 *   P1.1 → ADC0832 DI
 *   P1.2 → ADC0832 DO
 *   P1.3 → ADC0832 CLK
 *
 *  ── 电机驱动L298N ──
 *   P3.2 → L298N IN1   (固定高电平，电机方向)
 *   P3.3 → L298N IN2   (固定低电平)
 *   P3.4 → L298N ENA   (PWM调速，Timer0中断产生)
 *
 *  ── LED指示灯 ──
 *   P2.0 → 绿色LED    (小雨指示，经330Ω限流)
 *   P2.1 → 黄色LED    (中雨指示)
 *   P2.2 → 红色LED    (大雨指示)
 *
 *  ── 按键 ──
 *   P3.5 → KEY1  (手动启动，低有效，10kΩ上拉)
 *   P3.6 → KEY2  (手动停止)
 *   P3.7 → KEY3  (手动/自动模式切换)
 *
 *  ── 时钟与复位 ──
 *   XTAL1/XTAL2 → 11.0592MHz晶振 + 30pF电容
 *   RST → 10kΩ上拉5V + 10μF电容接GND（上电自动复位）
 *   EA  → 直接接5V（使用内部Flash）
 *============================================================
 * 软件架构说明：
 *   Timer0 中断（1ms）：软件PWM生成，控制L298N ENA
 *   Timer1 中断（4ms）：四位数码管动态扫描，OLED刷新计时
 *   主循环（约200ms）：读ADC→滤波→判等级→更新LED→
 *                      控速→扫键→OLED刷新
 *
 * 关键定时计算（11.0592MHz晶振）：
 *   机器周期 = 12/11.0592MHz ≈ 1.085μs
 *   Timer0 1ms：TH0=0xFC, TL0=0x66（重装值65536-921=64615）
 *   Timer1 4ms：TH1=0xF0, TL1=0x9C（重装值65536-3686=61850）
 *============================================================*/

#include <reg52.h>
#include <intrins.h>
#include "ADC0832.h"
#include "oled.h"

/*============================================================
 *  引脚定义
 *============================================================*/

/* ── 74HC595（数码管段码驱动） ── */
sbit HC595_SER   = P0^0;   /* 串行数据输入（串到并） */
sbit HC595_RCLK  = P0^1;   /* 存储寄存器时钟（上升沿锁存） */
sbit HC595_SRCLK = P0^2;   /* 移位寄存器时钟 */

/* ── 数码管位选（高电平选中，经S8050三极管，共阴极） ── */
sbit COM1 = P2^4;   /* 千位（最高位，实际此处显示百位） */
sbit COM2 = P2^5;   /* 百位 */
sbit COM3 = P2^6;   /* 十位 */
sbit COM4 = P2^7;   /* 个位（最低位） */

/* ── LED指示灯（高电平驱动） ── */
sbit LED_G = P2^0;  /* 绿：小雨 */
sbit LED_Y = P2^1;  /* 黄：中雨 */
sbit LED_R = P2^2;  /* 红：大雨 */

/* ── 电机控制（L298N） ── */
sbit MOTOR_PWM = P3^4;  /* ENA：PWM调速（Timer0产生） */
sbit MOTOR_IN1 = P3^2;  /* 方向控制1（固定高，单向旋转） */
sbit MOTOR_IN2 = P3^3;  /* 方向控制2（固定低） */

/* ── 按键（低电平有效，外接10kΩ上拉到VCC） ── */
sbit KEY1 = P3^5;   /* 手动启动 */
sbit KEY2 = P3^6;   /* 手动停止 */
sbit KEY3 = P3^7;   /* 模式切换（自动?手动） */

/*============================================================
 *  共阴极数码管段码表（0~9）
 *  位序：dp-g-f-e-d-c-b-a（与74HC595 Q7~Q0对应）
 *  共阴极：段对应位为1时该段亮
 *============================================================*/
unsigned char code SEG_CODE[] =
{
    0x3F,   /* 0:  0011 1111  a b c d e f    */
    0x06,   /* 1:  0000 0110      b c         */
    0x5B,   /* 2:  0101 1011  a b   d e   g  */
    0x4F,   /* 3:  0100 1111  a b c d     g  */
    0x66,   /* 4:  0110 0110      b c   f g  */
    0x6D,   /* 5:  0110 1101  a   c d   f g  */
    0x7D,   /* 6:  0111 1101  a   c d e f g  */
    0x07,   /* 7:  0000 0111  a b c          */
    0x7F,   /* 8:  0111 1111  a b c d e f g  */
    0x6F,   /* 9:  0110 1111  a b c d   f g  */
};

/*============================================================
 *  全局系统状态变量
 *============================================================*/
unsigned char g_adc_val   = 0;  /* ADC0832采集值（0~255） */
unsigned char g_rain_lv   = 0;  /* 雨量等级 0=无 1=小 2=中 3=大 */
unsigned char g_pwm_duty  = 0;  /* PWM占空比（0~99，对应0%~99%） */
unsigned char g_auto_mode = 1;  /* 运行模式：1=自动，0=手动 */
unsigned char g_run       = 0;  /* 手动模式运行标志 */

/* 等级切换延时保护（防止雨量抖动导致频繁切换） */
unsigned char g_stable_cnt = 0;
unsigned char g_new_lv     = 0;

/* Timer0 PWM计数（0~99，100步一个周期=100ms） */
unsigned char g_pwm_cnt = 0;

/* Timer1 数码管位选轮询 */
unsigned char g_seg_pos = 0;    /* 当前扫描位（0~3） */

/* 数码管显示缓冲（4位，从高位到低位） */
unsigned char g_disp[4] = {0, 0, 0, 0};

/* OLED刷新计时（每125次×4ms = 500ms刷新一次，避免阻塞太久） */
unsigned char g_oled_timer = 0;

/*============================================================
 *  延时函数
 *============================================================*/

/*------------------------------------------------------------
 * delay_ms()  毫秒延时（11.0592MHz下约1ms/次）
 *------------------------------------------------------------*/
void delay_ms(unsigned int ms)
{
    unsigned int i, j;
    for (i = ms; i > 0; i--)
        for (j = 120; j > 0; j--);
}

/*============================================================
 *  74HC595 + 数码管驱动
 *============================================================*/

/*------------------------------------------------------------
 * HC595_SendByte()  向74HC595发送1字节（MSB先移入）
 * 调用完毕后RCLK上升沿将数据从移位寄存器锁存到输出寄存器
 *------------------------------------------------------------*/
void HC595_SendByte(unsigned char dat)
{
    unsigned char i;
    for (i = 0; i < 8; i++)
    {
        HC595_SRCLK = 0;
        HC595_SER   = (dat & 0x80) ? 1 : 0;
        dat       <<= 1;
        HC595_SRCLK = 1;    /* 上升沿移入1位 */
    }
    HC595_RCLK = 0;
    HC595_RCLK = 1;         /* 上升沿锁存到输出 */
}

/*------------------------------------------------------------
 * SEG_Update()  根据ADC值更新数码管显示缓冲区
 * 显示格式：最多3位数字（0~255），高位不显示前导零（显示空格）
 *------------------------------------------------------------*/
void SEG_Update(unsigned char val)
{
    unsigned char hundreds = val / 100;
    unsigned char tens     = (val % 100) / 10;
    unsigned char ones     = val % 10;

    /* 高位消零：百位为0时显示空格，十位为0且百位也为0时显示空格 */
    g_disp[0] = (hundreds > 0) ? hundreds : 10;        /* 10=空格索引 */
    g_disp[1] = (hundreds > 0 || tens > 0) ? tens : 10;
    g_disp[2] = ones;
    g_disp[3] = g_rain_lv;  /* 个位显示雨量等级（0~3） */
}

/*------------------------------------------------------------
 * SEG_Scan()  数码管动态扫描（在Timer1中断中调用，每4ms切换一位）
 * 采用"关所有位→发段码→选位"的顺序，消除拖影
 *------------------------------------------------------------*/
void SEG_Scan(void)
{
    /* ① 关闭所有位（防止切换瞬间出现拖影） */
    COM1 = 0; COM2 = 0; COM3 = 0; COM4 = 0;

    /* ② 通过74HC595输出当前位的段码 */
    if (g_disp[g_seg_pos] == 10)
        HC595_SendByte(0x00);           /* 空格：所有段不亮 */
    else
        HC595_SendByte(SEG_CODE[g_disp[g_seg_pos]]);

    /* ③ 选中当前位 */
    switch (g_seg_pos)
    {
        case 0: COM1 = 1; break;
        case 1: COM2 = 1; break;
        case 2: COM3 = 1; break;
        case 3: COM4 = 1; break;
        default: break;
    }

    /* ④ 移到下一位 */
    g_seg_pos = (g_seg_pos + 1) & 0x03;
}

/*============================================================
 *  LED指示灯控制
 *============================================================*/

/*------------------------------------------------------------
 * LED_Update()  根据雨量等级更新三色LED状态
 * 等级 0=无雨（全灭），1=小雨（绿），2=中雨（黄），3=大雨（红）
 *------------------------------------------------------------*/
void LED_Update(unsigned char lv)
{
    LED_G = 0; LED_Y = 0; LED_R = 0;   /* 先全灭 */
    switch (lv)
    {
        case 1: LED_G = 1; break;
        case 2: LED_Y = 1; break;
        case 3: LED_R = 1; break;
        default: break;                  /* case 0：无雨，保持全灭 */
    }
}

/*============================================================
 *  按键扫描（软件消抖，下降沿触发）
 *============================================================*/

/*------------------------------------------------------------
 * Key_Scan()  扫描三个按键，检测下降沿（松开→按下）
 * KEY1：手动模式下启动电机（50%占空比）
 * KEY2：手动模式下停止电机
 * KEY3：切换自动/手动模式
 * 注意：按键优先级高于自动模式，与开题报告一致
 *------------------------------------------------------------*/
void Key_Scan(void)
{
    static unsigned char k1_prev = 1;
    static unsigned char k2_prev = 1;
    static unsigned char k3_prev = 1;
    unsigned char k1, k2, k3;

    /* 读取当前电平 */
    k1 = KEY1; k2 = KEY2; k3 = KEY3;

    /* 延时消抖（主循环已有延时，此处额外加短延时即可） */
    delay_ms(10);

    /* KEY1：手动启动 */
    if (k1 == 0 && k1_prev == 1)   /* 检测下降沿 */
    {
        if (!g_auto_mode)           /* 仅手动模式有效 */
        {
            g_run       = 1;
            MOTOR_IN1   = 1;
            MOTOR_IN2   = 0;
            g_pwm_duty  = 50;       /* 固定50%占空比启动 */
        }
    }

    /* KEY2：手动停止 */
    if (k2 == 0 && k2_prev == 1)
    {
        if (!g_auto_mode)
        {
            g_run      = 0;
            g_pwm_duty = 0;
        }
    }

    /* KEY3：模式切换 */
    if (k3 == 0 && k3_prev == 1)
    {
        g_auto_mode = !g_auto_mode;
        if (g_auto_mode)
        {
            /* 切换回自动模式时，清除手动状态 */
            g_run      = 0;
            g_pwm_duty = 0;
        }
    }

    /* 保存当前电平用于下次边沿检测 */
    k1_prev = k1;
    k2_prev = k2;
    k3_prev = k3;
}

/*============================================================
 *  雨量等级判断（含延时保护算法）
 *============================================================*/

/*------------------------------------------------------------
 * Rain_JudgeLevel()  根据ADC值判断雨量等级
 * 雨量阈值说明（需根据实测FC-37传感器调整！）：
 *   ADC值 > 200 → 无雨  （传感器干燥，电阻最大，电压最高≈5V）
 *   150 < ADC ≤ 200 → 小雨
 *   100 < ADC ≤ 150 → 中雨
 *   ADC ≤ 100       → 大雨  （大量水珠，电阻最小，电压最低≈0V）
 *
 * 延时保护：新等级需连续判断 STABLE_CNT_MAX 次才切换
 *           防止雨量边界附近的传感器抖动导致电机频繁启停
 *------------------------------------------------------------*/
#define STABLE_CNT_MAX  5   /* 需连续5次（约1秒）才切换等级 */

void Rain_JudgeLevel(unsigned char adc)
{
    unsigned char new_lv;

    /* 雨量等级判断（阈值待实测标定后修改） */
    if      (adc > 200) new_lv = 0;    /* 无雨 */
    else if (adc > 150) new_lv = 1;    /* 小雨 */
    else if (adc > 100) new_lv = 2;    /* 中雨 */
    else                new_lv = 3;    /* 大雨 */

    /* 延时保护：等级未变则清计数，变化则计数直到稳定 */
    if (new_lv == g_rain_lv)
    {
        g_stable_cnt = 0;
    }
    else
    {
        g_stable_cnt++;
        if (g_stable_cnt >= STABLE_CNT_MAX)
        {
            g_rain_lv    = new_lv;
            g_stable_cnt = 0;
        }
    }
}

/*============================================================
 *  自动调速（PWM目标占空比渐变）
 *============================================================*/

/*------------------------------------------------------------
 * Motor_AutoControl()  自动模式下根据雨量等级设置目标PWM
 * 使用渐变方式（每调用一次±1）避免速度突变，
 * 模拟真实雨刮器平滑加减速
 *------------------------------------------------------------*/
void Motor_AutoControl(void)
{
    unsigned char duty_target;

    /* 根据雨量等级设定目标占空比 */
    switch (g_rain_lv)
    {
        case 0: duty_target =  0; break;   /* 无雨：停止   */
        case 1: duty_target = 30; break;   /* 小雨：低速   */
        case 2: duty_target = 60; break;   /* 中雨：中速   */
        case 3: duty_target = 90; break;   /* 大雨：高速   */
        default: duty_target = 0; break;
    }

    /* 渐变：每次主循环调用变化±1，平滑过渡 */
    if (g_pwm_duty < duty_target)
        g_pwm_duty++;
    else if (g_pwm_duty > duty_target)
        g_pwm_duty--;
}

/*============================================================
 *  中断服务程序
 *============================================================*/

/*------------------------------------------------------------
 * Timer0_ISR  软件PWM生成（定时周期1ms）
 * 原理：100ms为一个PWM周期（g_pwm_cnt 0~99计数）
 *       当计数值 < g_pwm_duty 时，ENA输出高电平（电机使能）
 *       否则输出低电平（电机停止）
 *       实际PWM频率 = 1000Hz / 100 = 10Hz（对直流电机足够）
 * 重要：MOTOR_IN1/IN2固定方向，雨刮器通过曲柄连杆实现往复，
 *       电机本身只需单向连续旋转，速度由PWM控制
 *------------------------------------------------------------*/
void Timer0_ISR(void) interrupt 1
{
    /* 重装初值（确保1ms周期精准） */
    TH0 = 0xFC;
    TL0 = 0x66;

    /* 软件PWM输出 */
    g_pwm_cnt++;
    if (g_pwm_cnt >= 100)
        g_pwm_cnt = 0;

    /* 当占空比为0时强制停止（避免始终输出高脉冲） */
    if (g_pwm_duty == 0)
        MOTOR_PWM = 0;
    else
        MOTOR_PWM = (g_pwm_cnt < g_pwm_duty) ? 1 : 0;
}

/*------------------------------------------------------------
 * Timer1_ISR  数码管动态扫描 + OLED刷新计时（定时周期4ms）
 * 四位数码管每4ms切换一位，完整扫描一轮 = 16ms（约62Hz）
 * 高于50Hz即无闪烁感
 * OLED刷新：累计到 500ms（125×4ms）时在主循环触发刷新
 *------------------------------------------------------------*/
void Timer1_ISR(void) interrupt 3
{
    /* 重装初值 */
    TH1 = 0xF0;
    TL1 = 0x9C;

    /* 数码管扫描 */
    SEG_Scan();

    /* OLED刷新计时 */
    g_oled_timer++;
    /* 计时到125时由主循环处理（不在中断中调用I2C，避免占用时间） */
}

/*============================================================
 *  主函数
 *============================================================*/
void main(void)
{
    /*----------------------------------------------------------
     * ① 初始化I/O口状态
     *----------------------------------------------------------*/
    P0 = 0x00;      /* 74HC595数据线全低 */
    P1 = 0xFF;      /* ADC/OLED引脚初始高（P1口上拉） */
    P2 = 0x00;      /* LED全灭，数码管位选全关 */
    P3 = 0xFF;      /* 按键引脚上拉，L298N初始低 */

    /* 电机方向固定（曲柄连杆单向旋转实现往复） */
    MOTOR_IN1  = 1;
    MOTOR_IN2  = 0;
    MOTOR_PWM  = 0;   /* 初始停止 */

    /* LED全灭 */
    LED_G = 0; LED_Y = 0; LED_R = 0;

    /*----------------------------------------------------------
     * ② 定时器初始化
     *----------------------------------------------------------*/
    TMOD = 0x11;    /* T0和T1均配置为模式1（16位不自动重装） */

    /* Timer0：1ms，用于软件PWM */
    TH0 = 0xFC;
    TL0 = 0x66;
    ET0 = 1;        /* 允许Timer0中断 */
    TR0 = 1;        /* 启动Timer0 */

    /* Timer1：4ms，用于数码管动态扫描 */
    TH1 = 0xF0;
    TL1 = 0x9C;
    ET1 = 1;        /* 允许Timer1中断 */
    TR1 = 1;        /* 启动Timer1 */

    EA = 1;         /* 开总中断 */

    /*----------------------------------------------------------
     * ③ OLED初始化 + 显示开机画面
     *----------------------------------------------------------*/
    OLED_Init();
    OLED_ShowBootScreen();  /* 显示：RainWiper V4.0 / 五邑大学 / 学号 / 姓名 */
    delay_ms(2000);         /* 开机画面停留2秒 */
    OLED_Clear();

    /*----------------------------------------------------------
     * ④ 数码管初始显示000
     *----------------------------------------------------------*/
    SEG_Update(0);

    /*----------------------------------------------------------
     * ⑤ 主循环（每次约200ms）
     *----------------------------------------------------------*/
    while (1)
    {
        /*── A. 读取ADC，8次滑动平均滤波 ──*/
        g_adc_val = ADC0832_Filter();

        /*── B. 更新数码管显示缓冲 ──*/
        SEG_Update(g_adc_val);

        /*── C. 判断雨量等级（含延时保护） ──*/
        Rain_JudgeLevel(g_adc_val);

        /*── D. 更新LED指示灯 ──*/
        LED_Update(g_rain_lv);

        /*── E. 电机控速 ──*/
        if (g_auto_mode)
        {
            Motor_AutoControl();    /* 自动模式：根据雨量等级渐变占空比 */
        }
        /* 手动模式下，g_pwm_duty由按键回调直接设置，此处不操作 */

        /*── F. 按键扫描（优先级高于自动模式） ──*/
        Key_Scan();

        /*── G. OLED刷新（每500ms一次，非阻塞判断） ──*/
        if (g_oled_timer >= 125)    /* 125 × 4ms = 500ms */
        {
            g_oled_timer = 0;
            OLED_RefreshAll(g_adc_val,
                            g_rain_lv,
                            g_pwm_duty,
                            g_auto_mode);
        }

        /*── H. 主循环延时（约200ms） ──*/
        delay_ms(200);
    }
}

/*============================================================
 * === 雨量阈值调试说明 ===
 * 传感器实测步骤：
 *  1. 干燥时，用串口打印 g_adc_val，记录数值（通常190~255）
 *  2. 轻喷水（小雨），记录数值下降范围
 *  3. 多喷水（中雨），记录数值
 *  4. 大量喷水（大雨），记录数值（通常<100）
 *  5. 根据步骤1~4修改 Rain_JudgeLevel() 中的阈值200/150/100
 *
 * === PWM占空比调试说明 ===
 *  若低速时电机力矩不足卡死：将小雨占空比从30%提高到40%
 *  若高速时机构有异响：将大雨占空比从90%降低到80%
 *
 * === PCB丝印信息 ===
 *  在嘉立创EDA → PCB → 丝印层(F.SilkS) → 放置文字：
 *    五邑大学  |  220710班  |  3222004950  |  梁嘉惠
 *  字体大小1.0mm，放置于PCB右下角或背面空白区
 *============================================================*/