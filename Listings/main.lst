C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*============================================================
   2           * main.c  --  基于STC89C52单片机的智能汽车雨刮器模拟系统
   3           *             主程序（完整版，数码管+OLED双显示）
   4           *
   5           * 作者：梁嘉惠  学号：3222004950
   6           * 学校：五邑大学 电子与信息工程学院  班级：220710
   7           * 指导教师：龙佳乐 副教授
   8           * 编译器：Keil C51  主频：11.0592MHz
   9           * 版本：V4.0  日期：2025年12月
  10           *============================================================
  11           * 硬件资源分配总览：
  12           *
  13           *  ── 数码管显示（开题报告必要功能） ──
  14           *   P0.0 → 74HC595 SER  (段码串行数据)
  15           *   P0.1 → 74HC595 RCLK (存储时钟)
  16           *   P0.2 → 74HC595 SRCLK(移位时钟)
  17           *   P2.4 → 数码管COM1   (千位，经S8050三极管驱动)
  18           *   P2.5 → 数码管COM2   (百位)
  19           *   P2.6 → 数码管COM3   (十位)
  20           *   P2.7 → 数码管COM4   (个位)
  21           *
  22           *  ── OLED显示（成品扩展功能） ──
  23           *   P1.6 → OLED SCL    (I2C时钟，外接4.7kΩ上拉到5V)
  24           *   P1.7 → OLED SDA    (I2C数据，外接4.7kΩ上拉到5V)
  25           *
  26           *  ── ADC0832（雨量采集） ──
  27           *   P1.0 → ADC0832 CS
  28           *   P1.1 → ADC0832 DI
  29           *   P1.2 → ADC0832 DO
  30           *   P1.3 → ADC0832 CLK
  31           *
  32           *  ── 电机驱动L298N ──
  33           *   P3.2 → L298N IN1   (固定高电平，电机方向)
  34           *   P3.3 → L298N IN2   (固定低电平)
  35           *   P3.4 → L298N ENA   (PWM调速，Timer0中断产生)
  36           *
  37           *  ── LED指示灯 ──
  38           *   P2.0 → 绿色LED    (小雨指示，经330Ω限流)
  39           *   P2.1 → 黄色LED    (中雨指示)
  40           *   P2.2 → 红色LED    (大雨指示)
  41           *
  42           *  ── 按键 ──
  43           *   P3.5 → KEY1  (手动启动，低有效，10kΩ上拉)
  44           *   P3.6 → KEY2  (手动停止)
  45           *   P3.7 → KEY3  (手动/自动模式切换)
  46           *
  47           *  ── 时钟与复位 ──
  48           *   XTAL1/XTAL2 → 11.0592MHz晶振 + 30pF电容
  49           *   RST → 10kΩ上拉5V + 10μF电容接GND（上电自动复位）
  50           *   EA  → 直接接5V（使用内部Flash）
  51           *============================================================
  52           * 软件架构说明：
  53           *   Timer0 中断（1ms）：软件PWM生成，控制L298N ENA
  54           *   Timer1 中断（4ms）：四位数码管动态扫描，OLED刷新计时
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 2   

  55           *   主循环（约200ms）：读ADC→滤波→判等级→更新LED→
  56           *                      控速→扫键→OLED刷新
  57           *
  58           * 关键定时计算（11.0592MHz晶振）：
  59           *   机器周期 = 12/11.0592MHz ≈ 1.085μs
  60           *   Timer0 1ms：TH0=0xFC, TL0=0x66（重装值65536-921=64615）
  61           *   Timer1 4ms：TH1=0xF0, TL1=0x9C（重装值65536-3686=61850）
  62           *============================================================*/
  63          
  64          #include <reg52.h>
  65          #include <intrins.h>
  66          #include "ADC0832.h"
*** WARNING C318 IN LINE 66 OF main.c: can't open file 'ADC0832.h'
  67          #include "oled.h"
*** WARNING C318 IN LINE 67 OF main.c: can't open file 'oled.h'
  68          
  69          /*============================================================
  70           *  引脚定义
  71           *============================================================*/
  72          
  73          /* ── 74HC595（数码管段码驱动） ── */
  74          sbit HC595_SER   = P0^0;   /* 串行数据输入（串到并） */
  75          sbit HC595_RCLK  = P0^1;   /* 存储寄存器时钟（上升沿锁存） */
  76          sbit HC595_SRCLK = P0^2;   /* 移位寄存器时钟 */
  77          
  78          /* ── 数码管位选（高电平选中，经S8050三极管，共阴极） ── */
  79          sbit COM1 = P2^4;   /* 千位（最高位，实际此处显示百位） */
  80          sbit COM2 = P2^5;   /* 百位 */
  81          sbit COM3 = P2^6;   /* 十位 */
  82          sbit COM4 = P2^7;   /* 个位（最低位） */
  83          
  84          /* ── LED指示灯（高电平驱动） ── */
  85          sbit LED_G = P2^0;  /* 绿：小雨 */
  86          sbit LED_Y = P2^1;  /* 黄：中雨 */
  87          sbit LED_R = P2^2;  /* 红：大雨 */
  88          
  89          /* ── 电机控制（L298N） ── */
  90          sbit MOTOR_PWM = P3^4;  /* ENA：PWM调速（Timer0产生） */
  91          sbit MOTOR_IN1 = P3^2;  /* 方向控制1（固定高，单向旋转） */
  92          sbit MOTOR_IN2 = P3^3;  /* 方向控制2（固定低） */
  93          
  94          /* ── 按键（低电平有效，外接10kΩ上拉到VCC） ── */
  95          sbit KEY1 = P3^5;   /* 手动启动 */
  96          sbit KEY2 = P3^6;   /* 手动停止 */
  97          sbit KEY3 = P3^7;   /* 模式切换（自动↔手动） */
  98          
  99          /*============================================================
 100           *  共阴极数码管段码表（0~9）
 101           *  位序：dp-g-f-e-d-c-b-a（与74HC595 Q7~Q0对应）
 102           *  共阴极：段对应位为1时该段亮
 103           *============================================================*/
 104          unsigned char code SEG_CODE[] =
 105          {
 106              0x3F,   /* 0:  0011 1111  a b c d e f    */
 107              0x06,   /* 1:  0000 0110      b c         */
 108              0x5B,   /* 2:  0101 1011  a b   d e   g  */
 109              0x4F,   /* 3:  0100 1111  a b c d     g  */
 110              0x66,   /* 4:  0110 0110      b c   f g  */
 111              0x6D,   /* 5:  0110 1101  a   c d   f g  */
 112              0x7D,   /* 6:  0111 1101  a   c d e f g  */
 113              0x07,   /* 7:  0000 0111  a b c          */
 114              0x7F,   /* 8:  0111 1111  a b c d e f g  */
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 3   

 115              0x6F,   /* 9:  0110 1111  a b c d   f g  */
 116          };
 117          
 118          /*============================================================
 119           *  全局系统状态变量
 120           *============================================================*/
 121          unsigned char g_adc_val   = 0;  /* ADC0832采集值（0~255） */
 122          unsigned char g_rain_lv   = 0;  /* 雨量等级 0=无 1=小 2=中 3=大 */
 123          unsigned char g_pwm_duty  = 0;  /* PWM占空比（0~99，对应0%~99%） */
 124          unsigned char g_auto_mode = 1;  /* 运行模式：1=自动，0=手动 */
 125          unsigned char g_run       = 0;  /* 手动模式运行标志 */
 126          
 127          /* 等级切换延时保护（防止雨量抖动导致频繁切换） */
 128          unsigned char g_stable_cnt = 0;
 129          unsigned char g_new_lv     = 0;
 130          
 131          /* Timer0 PWM计数（0~99，100步一个周期=100ms） */
 132          unsigned char g_pwm_cnt = 0;
 133          
 134          /* Timer1 数码管位选轮询 */
 135          unsigned char g_seg_pos = 0;    /* 当前扫描位（0~3） */
 136          
 137          /* 数码管显示缓冲（4位，从高位到低位） */
 138          unsigned char g_disp[4] = {0, 0, 0, 0};
 139          
 140          /* OLED刷新计时（每125次×4ms = 500ms刷新一次，避免阻塞太久） */
 141          unsigned char g_oled_timer = 0;
 142          
 143          /*============================================================
 144           *  延时函数
 145           *============================================================*/
 146          
 147          /*------------------------------------------------------------
 148           * delay_ms()  毫秒延时（11.0592MHz下约1ms/次）
 149           *------------------------------------------------------------*/
 150          void delay_ms(unsigned int ms)
 151          {
 152   1          unsigned int i, j;
 153   1          for (i = ms; i > 0; i--)
 154   1              for (j = 120; j > 0; j--);
 155   1      }
 156          
 157          /*============================================================
 158           *  74HC595 + 数码管驱动
 159           *============================================================*/
 160          
 161          /*------------------------------------------------------------
 162           * HC595_SendByte()  向74HC595发送1字节（MSB先移入）
 163           * 调用完毕后RCLK上升沿将数据从移位寄存器锁存到输出寄存器
 164           *------------------------------------------------------------*/
 165          void HC595_SendByte(unsigned char dat)
 166          {
 167   1          unsigned char i;
 168   1          for (i = 0; i < 8; i++)
 169   1          {
 170   2              HC595_SRCLK = 0;
 171   2              HC595_SER   = (dat & 0x80) ? 1 : 0;
 172   2              dat       <<= 1;
 173   2              HC595_SRCLK = 1;    /* 上升沿移入1位 */
 174   2          }
 175   1          HC595_RCLK = 0;
 176   1          HC595_RCLK = 1;         /* 上升沿锁存到输出 */
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 4   

 177   1      }
 178          
 179          /*------------------------------------------------------------
 180           * SEG_Update()  根据ADC值更新数码管显示缓冲区
 181           * 显示格式：最多3位数字（0~255），高位不显示前导零（显示空格）
 182           *------------------------------------------------------------*/
 183          void SEG_Update(unsigned char val)
 184          {
 185   1          unsigned char hundreds = val / 100;
 186   1          unsigned char tens     = (val % 100) / 10;
 187   1          unsigned char ones     = val % 10;
 188   1      
 189   1          /* 高位消零：百位为0时显示空格，十位为0且百位也为0时显示空格 */
 190   1          g_disp[0] = (hundreds > 0) ? hundreds : 10;        /* 10=空格索引 */
 191   1          g_disp[1] = (hundreds > 0 || tens > 0) ? tens : 10;
 192   1          g_disp[2] = ones;
 193   1          g_disp[3] = g_rain_lv;  /* 个位显示雨量等级（0~3） */
 194   1      }
 195          
 196          /*------------------------------------------------------------
 197           * SEG_Scan()  数码管动态扫描（在Timer1中断中调用，每4ms切换一位）
 198           * 采用"关所有位→发段码→选位"的顺序，消除拖影
 199           *------------------------------------------------------------*/
 200          void SEG_Scan(void)
 201          {
 202   1          /* ① 关闭所有位（防止切换瞬间出现拖影） */
 203   1          COM1 = 0; COM2 = 0; COM3 = 0; COM4 = 0;
 204   1      
 205   1          /* ② 通过74HC595输出当前位的段码 */
 206   1          if (g_disp[g_seg_pos] == 10)
 207   1              HC595_SendByte(0x00);           /* 空格：所有段不亮 */
 208   1          else
 209   1              HC595_SendByte(SEG_CODE[g_disp[g_seg_pos]]);
 210   1      
 211   1          /* ③ 选中当前位 */
 212   1          switch (g_seg_pos)
 213   1          {
 214   2              case 0: COM1 = 1; break;
 215   2              case 1: COM2 = 1; break;
 216   2              case 2: COM3 = 1; break;
 217   2              case 3: COM4 = 1; break;
 218   2              default: break;
 219   2          }
 220   1      
 221   1          /* ④ 移到下一位 */
 222   1          g_seg_pos = (g_seg_pos + 1) & 0x03;
 223   1      }
 224          
 225          /*============================================================
 226           *  LED指示灯控制
 227           *============================================================*/
 228          
 229          /*------------------------------------------------------------
 230           * LED_Update()  根据雨量等级更新三色LED状态
 231           * 等级 0=无雨（全灭），1=小雨（绿），2=中雨（黄），3=大雨（红）
 232           *------------------------------------------------------------*/
 233          void LED_Update(unsigned char lv)
 234          {
 235   1          LED_G = 0; LED_Y = 0; LED_R = 0;   /* 先全灭 */
 236   1          switch (lv)
 237   1          {
 238   2              case 1: LED_G = 1; break;
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 5   

 239   2              case 2: LED_Y = 1; break;
 240   2              case 3: LED_R = 1; break;
 241   2              default: break;                  /* case 0：无雨，保持全灭 */
 242   2          }
 243   1      }
 244          
 245          /*============================================================
 246           *  按键扫描（软件消抖，下降沿触发）
 247           *============================================================*/
 248          
 249          /*------------------------------------------------------------
 250           * Key_Scan()  扫描三个按键，检测下降沿（松开→按下）
 251           * KEY1：手动模式下启动电机（50%占空比）
 252           * KEY2：手动模式下停止电机
 253           * KEY3：切换自动/手动模式
 254           * 注意：按键优先级高于自动模式，与开题报告一致
 255           *------------------------------------------------------------*/
 256          void Key_Scan(void)
 257          {
 258   1          static unsigned char k1_prev = 1;
 259   1          static unsigned char k2_prev = 1;
 260   1          static unsigned char k3_prev = 1;
 261   1          unsigned char k1, k2, k3;
 262   1      
 263   1          /* 读取当前电平 */
 264   1          k1 = KEY1; k2 = KEY2; k3 = KEY3;
 265   1      
 266   1          /* 延时消抖（主循环已有延时，此处额外加短延时即可） */
 267   1          delay_ms(10);
 268   1      
 269   1          /* KEY1：手动启动 */
 270   1          if (k1 == 0 && k1_prev == 1)   /* 检测下降沿 */
 271   1          {
 272   2              if (!g_auto_mode)           /* 仅手动模式有效 */
 273   2              {
 274   3                  g_run       = 1;
 275   3                  MOTOR_IN1   = 1;
 276   3                  MOTOR_IN2   = 0;
 277   3                  g_pwm_duty  = 50;       /* 固定50%占空比启动 */
 278   3              }
 279   2          }
 280   1      
 281   1          /* KEY2：手动停止 */
 282   1          if (k2 == 0 && k2_prev == 1)
 283   1          {
 284   2              if (!g_auto_mode)
 285   2              {
 286   3                  g_run      = 0;
 287   3                  g_pwm_duty = 0;
 288   3              }
 289   2          }
 290   1      
 291   1          /* KEY3：模式切换 */
 292   1          if (k3 == 0 && k3_prev == 1)
 293   1          {
 294   2              g_auto_mode = !g_auto_mode;
 295   2              if (g_auto_mode)
 296   2              {
 297   3                  /* 切换回自动模式时，清除手动状态 */
 298   3                  g_run      = 0;
 299   3                  g_pwm_duty = 0;
 300   3              }
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 6   

 301   2          }
 302   1      
 303   1          /* 保存当前电平用于下次边沿检测 */
 304   1          k1_prev = k1;
 305   1          k2_prev = k2;
 306   1          k3_prev = k3;
 307   1      }
 308          
 309          /*============================================================
 310           *  雨量等级判断（含延时保护算法）
 311           *============================================================*/
 312          
 313          /*------------------------------------------------------------
 314           * Rain_JudgeLevel()  根据ADC值判断雨量等级
 315           * 雨量阈值说明（需根据实测FC-37传感器调整！）：
 316           *   ADC值 > 200 → 无雨  （传感器干燥，电阻最大，电压最高≈5V）
 317           *   150 < ADC ≤ 200 → 小雨
 318           *   100 < ADC ≤ 150 → 中雨
 319           *   ADC ≤ 100       → 大雨  （大量水珠，电阻最小，电压最低≈0V）
 320           *
 321           * 延时保护：新等级需连续判断 STABLE_CNT_MAX 次才切换
 322           *           防止雨量边界附近的传感器抖动导致电机频繁启停
 323           *------------------------------------------------------------*/
 324          #define STABLE_CNT_MAX  5   /* 需连续5次（约1秒）才切换等级 */
 325          
 326          void Rain_JudgeLevel(unsigned char adc)
 327          {
 328   1          unsigned char new_lv;
 329   1      
 330   1          /* 雨量等级判断（阈值待实测标定后修改） */
 331   1          if      (adc > 200) new_lv = 0;    /* 无雨 */
 332   1          else if (adc > 150) new_lv = 1;    /* 小雨 */
 333   1          else if (adc > 100) new_lv = 2;    /* 中雨 */
 334   1          else                new_lv = 3;    /* 大雨 */
 335   1      
 336   1          /* 延时保护：等级未变则清计数，变化则计数直到稳定 */
 337   1          if (new_lv == g_rain_lv)
 338   1          {
 339   2              g_stable_cnt = 0;
 340   2          }
 341   1          else
 342   1          {
 343   2              g_stable_cnt++;
 344   2              if (g_stable_cnt >= STABLE_CNT_MAX)
 345   2              {
 346   3                  g_rain_lv    = new_lv;
 347   3                  g_stable_cnt = 0;
 348   3              }
 349   2          }
 350   1      }
 351          
 352          /*============================================================
 353           *  自动调速（PWM目标占空比渐变）
 354           *============================================================*/
 355          
 356          /*------------------------------------------------------------
 357           * Motor_AutoControl()  自动模式下根据雨量等级设置目标PWM
 358           * 使用渐变方式（每调用一次±1）避免速度突变，
 359           * 模拟真实雨刮器平滑加减速
 360           *------------------------------------------------------------*/
 361          void Motor_AutoControl(void)
 362          {
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 7   

 363   1          unsigned char duty_target;
 364   1      
 365   1          /* 根据雨量等级设定目标占空比 */
 366   1          switch (g_rain_lv)
 367   1          {
 368   2              case 0: duty_target =  0; break;   /* 无雨：停止   */
 369   2              case 1: duty_target = 30; break;   /* 小雨：低速   */
 370   2              case 2: duty_target = 60; break;   /* 中雨：中速   */
 371   2              case 3: duty_target = 90; break;   /* 大雨：高速   */
 372   2              default: duty_target = 0; break;
 373   2          }
 374   1      
 375   1          /* 渐变：每次主循环调用变化±1，平滑过渡 */
 376   1          if (g_pwm_duty < duty_target)
 377   1              g_pwm_duty++;
 378   1          else if (g_pwm_duty > duty_target)
 379   1              g_pwm_duty--;
 380   1      }
 381          
 382          /*============================================================
 383           *  中断服务程序
 384           *============================================================*/
 385          
 386          /*------------------------------------------------------------
 387           * Timer0_ISR  软件PWM生成（定时周期1ms）
 388           * 原理：100ms为一个PWM周期（g_pwm_cnt 0~99计数）
 389           *       当计数值 < g_pwm_duty 时，ENA输出高电平（电机使能）
 390           *       否则输出低电平（电机停止）
 391           *       实际PWM频率 = 1000Hz / 100 = 10Hz（对直流电机足够）
 392           * 重要：MOTOR_IN1/IN2固定方向，雨刮器通过曲柄连杆实现往复，
 393           *       电机本身只需单向连续旋转，速度由PWM控制
 394           *------------------------------------------------------------*/
 395          void Timer0_ISR(void) interrupt 1
 396          {
 397   1          /* 重装初值（确保1ms周期精准） */
 398   1          TH0 = 0xFC;
 399   1          TL0 = 0x66;
 400   1      
 401   1          /* 软件PWM输出 */
 402   1          g_pwm_cnt++;
 403   1          if (g_pwm_cnt >= 100)
 404   1              g_pwm_cnt = 0;
 405   1      
 406   1          /* 当占空比为0时强制停止（避免始终输出高脉冲） */
 407   1          if (g_pwm_duty == 0)
 408   1              MOTOR_PWM = 0;
 409   1          else
 410   1              MOTOR_PWM = (g_pwm_cnt < g_pwm_duty) ? 1 : 0;
 411   1      }
 412          
 413          /*------------------------------------------------------------
 414           * Timer1_ISR  数码管动态扫描 + OLED刷新计时（定时周期4ms）
 415           * 四位数码管每4ms切换一位，完整扫描一轮 = 16ms（约62Hz）
 416           * 高于50Hz即无闪烁感
 417           * OLED刷新：累计到 500ms（125×4ms）时在主循环触发刷新
 418           *------------------------------------------------------------*/
 419          void Timer1_ISR(void) interrupt 3
 420          {
 421   1          /* 重装初值 */
 422   1          TH1 = 0xF0;
 423   1          TL1 = 0x9C;
 424   1      
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 8   

 425   1          /* 数码管扫描 */
 426   1          SEG_Scan();
 427   1      
 428   1          /* OLED刷新计时 */
 429   1          g_oled_timer++;
 430   1          /* 计时到125时由主循环处理（不在中断中调用I2C，避免占用时间） */
 431   1      }
 432          
 433          /*============================================================
 434           *  主函数
 435           *============================================================*/
 436          void main(void)
 437          {
 438   1          /*----------------------------------------------------------
 439   1           * ① 初始化I/O口状态
 440   1           *----------------------------------------------------------*/
 441   1          P0 = 0x00;      /* 74HC595数据线全低 */
 442   1          P1 = 0xFF;      /* ADC/OLED引脚初始高（P1口上拉） */
 443   1          P2 = 0x00;      /* LED全灭，数码管位选全关 */
 444   1          P3 = 0xFF;      /* 按键引脚上拉，L298N初始低 */
 445   1      
 446   1          /* 电机方向固定（曲柄连杆单向旋转实现往复） */
 447   1          MOTOR_IN1  = 1;
 448   1          MOTOR_IN2  = 0;
 449   1          MOTOR_PWM  = 0;   /* 初始停止 */
 450   1      
 451   1          /* LED全灭 */
 452   1          LED_G = 0; LED_Y = 0; LED_R = 0;
 453   1      
 454   1          /*----------------------------------------------------------
 455   1           * ② 定时器初始化
 456   1           *----------------------------------------------------------*/
 457   1          TMOD = 0x11;    /* T0和T1均配置为模式1（16位不自动重装） */
 458   1      
 459   1          /* Timer0：1ms，用于软件PWM */
 460   1          TH0 = 0xFC;
 461   1          TL0 = 0x66;
 462   1          ET0 = 1;        /* 允许Timer0中断 */
 463   1          TR0 = 1;        /* 启动Timer0 */
 464   1      
 465   1          /* Timer1：4ms，用于数码管动态扫描 */
 466   1          TH1 = 0xF0;
 467   1          TL1 = 0x9C;
 468   1          ET1 = 1;        /* 允许Timer1中断 */
 469   1          TR1 = 1;        /* 启动Timer1 */
 470   1      
 471   1          EA = 1;         /* 开总中断 */
 472   1      
 473   1          /*----------------------------------------------------------
 474   1           * ③ OLED初始化 + 显示开机画面
 475   1           *----------------------------------------------------------*/
 476   1          OLED_Init();
*** WARNING C206 IN LINE 476 OF main.c: 'OLED_Init': missing function-prototype
 477   1          OLED_ShowBootScreen();  /* 显示：RainWiper V4.0 / 五邑大学 / 学号 / 姓名 */
*** WARNING C206 IN LINE 477 OF main.c: 'OLED_ShowBootScreen': missing function-prototype
 478   1          delay_ms(2000);         /* 开机画面停留2秒 */
 479   1          OLED_Clear();
*** WARNING C206 IN LINE 479 OF main.c: 'OLED_Clear': missing function-prototype
 480   1      
 481   1          /*----------------------------------------------------------
 482   1           * ④ 数码管初始显示000
 483   1           *----------------------------------------------------------*/
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 9   

 484   1          SEG_Update(0);
 485   1      
 486   1          /*----------------------------------------------------------
 487   1           * ⑤ 主循环（每次约200ms）
 488   1           *----------------------------------------------------------*/
 489   1          while (1)
 490   1          {
 491   2              /*── A. 读取ADC，8次滑动平均滤波 ──*/
 492   2              g_adc_val = ADC0832_Filter();
*** WARNING C206 IN LINE 492 OF main.c: 'ADC0832_Filter': missing function-prototype
 493   2      
 494   2              /*── B. 更新数码管显示缓冲 ──*/
 495   2              SEG_Update(g_adc_val);
 496   2      
 497   2              /*── C. 判断雨量等级（含延时保护） ──*/
 498   2              Rain_JudgeLevel(g_adc_val);
 499   2      
 500   2              /*── D. 更新LED指示灯 ──*/
 501   2              LED_Update(g_rain_lv);
 502   2      
 503   2              /*── E. 电机控速 ──*/
 504   2              if (g_auto_mode)
 505   2              {
 506   3                  Motor_AutoControl();    /* 自动模式：根据雨量等级渐变占空比 */
 507   3              }
 508   2              /* 手动模式下，g_pwm_duty由按键回调直接设置，此处不操作 */
 509   2      
 510   2              /*── F. 按键扫描（优先级高于自动模式） ──*/
 511   2              Key_Scan();
 512   2      
 513   2              /*── G. OLED刷新（每500ms一次，非阻塞判断） ──*/
 514   2              if (g_oled_timer >= 125)    /* 125 × 4ms = 500ms */
 515   2              {
 516   3                  g_oled_timer = 0;
 517   3                  OLED_RefreshAll(g_adc_val,
*** WARNING C206 IN LINE 517 OF main.c: 'OLED_RefreshAll': missing function-prototype
*** ERROR C267 IN LINE 517 OF main.c: 'OLED_RefreshAll': requires ANSI-style prototype
 518   3                                  g_rain_lv,
 519   3                                  g_pwm_duty,
 520   3                                  g_auto_mode);
 521   3              }
 522   2      
 523   2              /*── H. 主循环延时（约200ms） ──*/
 524   2              delay_ms(200);
 525   2          }
 526   1      }
 527          
 528          /*============================================================
 529           * === 雨量阈值调试说明 ===
 530           * 传感器实测步骤：
 531           *  1. 干燥时，用串口打印 g_adc_val，记录数值（通常190~255）
 532           *  2. 轻喷水（小雨），记录数值下降范围
 533           *  3. 多喷水（中雨），记录数值
 534           *  4. 大量喷水（大雨），记录数值（通常<100）
 535           *  5. 根据步骤1~4修改 Rain_JudgeLevel() 中的阈值200/150/100
 536           *
 537           * === PWM占空比调试说明 ===
 538           *  若低速时电机力矩不足卡死：将小雨占空比从30%提高到40%
 539           *  若高速时机构有异响：将大雨占空比从90%降低到80%
 540           *
 541           * === PCB丝印信息 ===
 542           *  在嘉立创EDA → PCB → 丝印层(F.SilkS) → 放置文字：
C51 COMPILER V9.60.7.0   MAIN                                                              02/24/2026 23:35:53 PAGE 10  

 543           *    五邑大学  |  220710班  |  3222004950  |  梁嘉惠
 544           *  字体大小1.0mm，放置于PCB右下角或背面空白区
 545           *============================================================*/

C51 COMPILATION COMPLETE.  7 WARNING(S),  1 ERROR(S)
